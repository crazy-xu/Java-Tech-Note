## 设计思路

    1. Spring IOC 工厂、单例、装饰器
    2. Spring AOP 代理、观察者
    3. Spring MVC 委派、适配器
    4. Spring JDBC 模版方法

按照如上思路来串行讲解Spring中的设计模式。

* 工厂模式 BeanFactory
* 单例模式 ApplicationContext
* 装饰器模式 BeanWrapper
* 代理模式 AopProxy
* 观察者模式 ContextLoaderListener
* 委派模式 DispatcherServlet
* 适配器模式 HandlerApdapter
* 模版方法模式 JdbcTemplate

软件设计七大原则：

| 设计原则 | 解释|
| :------ | ---- |
| 开闭原则     | 对扩展开放，对修改关闭。|
| 依赖倒置原则 | 通过抽象使各个类或者模块不相互影响，实现松耦合。|
| 单一职责原则 | 一个类、接口、方法只做一件事。|
| 接口隔离原则 | 尽量保证接口的纯洁性，客户端不应该依赖不需要的接口。|
| 迪米特法则 | 又叫最少知道原则，一个类对其所依赖的类知道得越少越好。|
| 里氏替换原则 | 子类可以扩展父类的功能但不能改变父类原有的功能|
| 合成复用原则 | 尽量使用对象组合、聚合，而不使用继承关系达到代码复用的目的。|



### 开闭原则（Open-Closed Principle, OCP）

> 指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，正是对扩展和修改两个行为的一个原则。
强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。
开闭原则，是面向对象设计中最基础的设计原则。在版本更新，尽可能不修改源代码，通过扩展增加新功能。
实现开闭原则的核心思想就是面向抽象编程，即实体应当通过扩展实现变化，而不是修改代码实现变化。

当书店里销售书籍
```java
public interface IBook {

    String getName();

    String getAuthor();

    double getPrice();
}
```
销售Java类书籍
```java
public class JavaBook implements IBook {

    private String name;
    private String author;
    private double price;

    public JavaBook(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;

    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public String getAuthor() {
        return this.author;
    }

    @Override
    public double getPrice() {
        return this.price;
    }
}
```
当给Java类书籍做活动时，如果修改 JavaBook 中的 getPrice() 方法，则会存在一定的风险，可能影响其他地方的调用结果。我们在不修改原有代
码前提前下，写一个处理优惠逻辑的类（ DiscountJavaBook ），这样降低系统的耦合性，不影响其它流程。
```java
public class DiscountJavaBook extends JavaBook {

    public DiscountJavaBook(String name, String author, double price) {
        super(name, author, price);
    }
    
    public double getOriginPrice() {
        return super.getPrice();
    }

    @Override
    public double getPrice() {
        return super.getPrice() * 0.8;
    }
}
```
类结构图，如下：

![GitHub](https://raw.githubusercontent.com/crazy-xu/Java-Tech-Note/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/OCP_%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.png "开闭原则类结构图")

### 依赖倒置原则（Dependence Inversion Principle, DIP）
> 设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。
通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。

```java
public class Programmer {
 
     public void studyJavaCourse() {
         System.out.println("这个程序猿正在学习Java~");
     }
 
     public void studyPythonCourse() {
         System.out.println("这个程序猿正在学习Python~");
     }
 
     public static void main(String[] args) {
         // 这个程序猿是个爱学习的猿儿，如果在学习新技术，我们的代码要从底层到高层（调用层）一次修改代码。
         // 系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险
         Programmer programmer = new Programmer();
         programmer.studyJavaCourse();
         programmer.studyPythonCourse();
     }
 }

```
> 这个程序猿是个爱学习的猿儿，如果在学习新技术，我们的代码要从底层到高层（调用层）一次修改代码。系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。

通过依赖倒置原则进行优化
```java
public interface ICourse {

    /**
     * 这个课程具有学习的功能
     */
    void study();
}
```
```java
public class JavaCourse implements ICourse {

    @Override
    public void study() {
        System.out.println("这个程序猿正在学习Java~");
    }
}
```
```java
public class PythonCourse implements ICourse {
    
    @Override
    public void study() {
        System.out.println("这个程序猿正在学习Python~");
    }
}
```
```java
public class GoCourse implements ICourse {

    @Override
    public void study() {
        System.out.println("这个程序猿正在学习Go~");
    }
}
```
```java
public class Programmer {

    public void study(ICourse course) {
        course.study();
    }

    public static void main(String[] args) {

        Programmer programmer = new Programmer();
        programmer.study(new JavaCourse());
        programmer.study(new PythonCourse());
        programmer.study(new GoCourse());
    }
}
```
在如上测试类中，对于新的技术，我只需要新建一个类，通过传参的方式告诉 Programmer，而不需要修改底层代码。实际上这是一种大家非常熟悉的方式，叫依赖注入。
```java
/**
* 如果 Programmer 是全局单例，则我们就需要选择用 Setter 方式来注入
*/
public class Programmer {

    private ICourse course;

    public void setCourse(ICourse course) {
        this.course = course;
    }

    public void study() {
        course.study();
    }

    public static void main(String[] args) {

        Programmer programmer = new Programmer();
        programmer.setCourse(new JavaCourse());
        programmer.study();
        programmer.setCourse(new PythonCourse());
        programmer.study();
        programmer.setCourse(new GoCourse());
        programmer.study();

    }
}
```
以抽象为基准比以细节为基准搭建起来的架构要稳定得多，所以，在接到需求之后，先画整体的分步骤流程图，面向接口编程。先写接口，在看实现类细节部分，来设计代码结构。

### 单一职责原则

### 接口隔离原则

### 迪米特法则

### 里式替换原则

### 合成复用原则

### 设计原则总结


