## MQ主要特点：
1、是一个独立运行的服务，生产者发送消息，消费者接收消费，需要先跟服务器建立连接。<br >
2、采用队列作为数据结构，有先进先出的特点。<br >
3、具有发布/订阅（publish/subscribe）的模型，消费者可以获取自己需要的消息。<br >
MQ 用来帮我们存储和转发消息。

## 为什么使用MQ：

#### 实现异步通信：
当一个异步过程调用发出后，调用者不会马上得到结果。而是在调用发出后，被调用着通过状态、通知来通知调用者，或者通过回调函数处理这个调用。
#### 实现系统解耦：
系统复杂，多个模块解耦，订单、库存、支付、通知。
#### 实现流量削峰：
MQ是Queue，有队列的特性，先进先出（FIFO）
#### 实现广播通信：
一对多通信，已订单系统退货为例，新增了结果通知系统，只需要增加队列监听即可，不需要生产者任何代码修改。

> 使用MQ会增加运维成本，系统的可用性降低，系统复杂性提高。根据实际情况来分析如何使用MQ。



## RabbitMQ简介

基于Erlang语言开发，Erlang是为电话交换机编写的语言，适合分布式和高并发。
RabbitMQ实现了AMQP协议（**重点了解AMQP协议**）

#### 1、Broker

默认端口5672，中介/经纪人

#### 2、Connection

生产着发送消息，还是消费者接收消息，都必须跟Broker之间建立一个连接，这个连接是TCP长连接。

#### 3、Channel

AMQP里引入了Channel的概念，是一个虚拟连接，可以理解成消息信道，这样就可以在保持的TCP长连接里面去创建和释放Channel，大大减少了资源消耗。不同的Channel是相互隔离的，每个Channel有自己的编号。

Channel是RabbitMQ原生API里面的最重要的编程接口，定义交换机、队列、绑定关系、发送消息、消费消息，调用的都是Channel接口的方法。

#### 4、Queue

队列是生产者和消费者的纽带，生产者发送消息到队列，在队列中存储，消费者从队列里消费消息。

RabbitMQ是用数据库来存储消息的，用Erlang开发，名字叫Mnesia。存储目录RabbitMQ/db/...

#### 5、Consumer

消费者消费消息有两种模式：Pull，Push

##### 5.1、Pull--主动拉取

对应方法是basicGet，消息存放在服务端，只有消费者主动获取才能拿到消息，如果每隔一段时间获取一次，消息的实时性就会降低。但是好处是可以根据自己的能力来决定消费消息的频率。

##### 5.2 Push--被动接收

对应方法是basicConsume，只要生产者发消息到服务器，就马上推送给消费者，消息保存在客户端，实时性较高，如果消费者消费不及时可能会造成消息积压。



> RabbitMQ中Pull和Push都有实现。Kafka和RocketMQ只有pull



一个消费者可以监听多个队列，一个队列也可以被多个消费者监听。

在生产环境中，建议一个消费者只处理一个队列消息。如果需要提升处理消息的能力，可以增加多个消费者，这时，消息就会在多个消费者之间轮询。

#### 6、Exchange

路由消息组件，将消息发送到Exchange，由它来分发消息，Exchange不会存储消息，只会根据规则分发消息。

Exchange需要和这些接收消息的队列建立绑定关系，并且为每个队列指定一个特殊标识。











、STOMP、MQTT、HTTP、WebSockets协议。

默认端口：5672
Broker 主机
跟Broker建立连接，TCP长链接。

Channel 虚拟连接，
使用数据库存储消息，Mnesia
Queue 是生产者和消费者的纽带。


Exchange交换机，与Queue队列建立绑定关系。


Vhost 主机


直连Direct类型交换机

主体Topic类型交换机
#有单词和没单词都可以


延迟消费，死信队列

消费模型
pull-消费者主动去broker拉取。basicGet
push-只要有消息到达队列就发送给消费者，消费者易堆积。basicConsume.


kafka 和RocketMQ 只有pull

