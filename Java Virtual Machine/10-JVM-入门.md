## 类加载机制
指我们将类的字节码文件所包含的数据读入内存，同时我们会提供数据的访问入口的一种特殊机制，类加载的最终产品是数据访问入口。

#### 加载.class文件的方式：
* 从本地文件系统中直接加载 
* 通过网络下载.class文件
> 场景：Web Applet 也就是我们的小程序应用
* 从zip、jar等归档文件中加载.class文件
> 后续演变成jar、war格式
* 从专有数据库中提取.class文件
> jsp应用从专有数据库中提取.class文件，较为少见
* 将Java源文件动态编译为.class文件，也就是运行时计算而成
> 动态代理
* 从加密文件中获取
> 防class文件被反编译的保护措施

### 装载（Load）
> 查找和导入class文件
* 1、通过一个类的的全限定名获取定义此类的二进制字节流
* 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 
* 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

方法区：类信息、静态变量、常量<br />
堆：代表被加载类的java.lang.Class对象<br />
即时编译之后的热点代码并不在这个阶段进入方法区。
### 链接（Link）
#### 验证（Verify） 
* 文件格式验证
> 验证是否符合Class文件格式的规范，并能被当前版本的虚拟机处理，保证输入的字节流能正确的解析并存储于方法区内。
* 元数据验证
> 对类的元数据信息进行语义校验（Java语法），保证不存在不符合Java语法规范的元数据信息。
* 字节码验证
> 进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
* 符号引用验证
> 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。
* -Xverify:none 取消验证

#### 准备（Prepare）
* 为类变量（静态变量）分配内存并且设置该类变量的默认初始值。
* final在编译的时候就会分配了，准备阶段会显式初始化；
* 不会为实例变量（也就是没加static）分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

> 进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象
一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a=1;那么a在准备阶段过后
的初始值为0，不为1，这时候只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编
译后，存放于类构造器()方法之中，所以a被赋值为1是在初始化阶段才会执行。

#### 解析（Resolve）

### 初始化（Initialize）















