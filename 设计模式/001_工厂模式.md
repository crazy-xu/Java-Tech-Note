# 工厂模式详解
### 工厂模式的历史由来

![GitHub](https://raw.githubusercontent.com/crazy-xu/Java-Tech-Note/master/设计模式/image/工厂模式_01.png "工厂模式")
#### 简单工厂模式（Simple Factory Pattern）

    指由一个工厂对象决定创建出哪一种产品类的实例。
    属于创建型模式，但他不属于GOF，23种设计模式。
    
    例如：
        LoggerFactory.getLogger(String name);
        LoggerFactory.getLogger(Class<?> clazz); // 同时该方法内部也调用了getLogger(clazz.getName())
        
    适用场景：
        工厂类负责创建的对象较少
        客户端只需要传入工厂的参数，对于如何创建对象的逻辑不需要关心。
    优点：
        只需传入一个正确的参数，就可以获取你所需要的对象，无需知道其创建的细节。
        里边根据传入的参数，进行if判断，去执行哪段逻辑。       
        
    缺点：
        工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。
        不易于扩展过于复杂的产品结构。
                
    就类似于农耕社会小作坊，什么活都可以接，随着业务进行扩展，后期会比较复杂。

#### 工厂方法模式（Factory Method Pattern）

    定义一个创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。属于创建型设计模式
    
    单一职责原则，不同的产品交由不同的工厂来创建，不同的工厂去负责不同的差异化逻辑。
    
    适用场景：
        创建对象需要大量重复的代码。
        客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
        一个类通过其子类来指定创建哪个对象。
    优点：
        用户只需要关心产品对应的工厂，无须关心创建、实现细节。
        加入新产品符合开闭原则，提高了产品的可扩展性。（有了新产品只需要增加对应的类，降低耦合）
        
    缺点：
        类的个数容易过多，增加了代码结构的复杂度。
        增加了系统的抽象性和理解难度。
    
    参数示例：        
![GitHub](https://raw.githubusercontent.com/crazy-xu/Java-Tech-Note/master/设计模式/image/工厂模式_02.png "工厂方法模式")

#### 抽象工厂模式（Abstract Factory Pattern）

    提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。
    属于创建型设计模式。
    
    适用场景：
        客户端不依赖于产品类实例如何被创建、实现等细节。
        强调一系列相关的产品对象（属于同一产品族）一起使用对象需要大量重复的代码。
        提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
    优点：
        具体产品在应用层代码隔离，无需关心创建细节。
        将一个系列的产品族统一到一起创建。
        
    缺点：
        规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
        增加了系统的抽象性和理解难度。
    
    抽象工厂不符合开闭原则，每新增一个功能，所有实现类都需要进行添加。结合业务进行使用。