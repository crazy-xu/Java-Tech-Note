1.它是Error的子类，Error类及其子类都是被划分在非检查异常之列的，就是说这些异常不能在编译阶段被检查出来，只能在运行时才会触发。

2.通过API文档里面的解释大致得出的结论就是说A依赖于B，但是执行的时候发现类B的定义发生了改变，这个改变是针对编译的时候发生了改变，也就是说将类A由java文件编译成.class文件的时候用到了类B的class文件，但是在执行的时候JVM发现真正用到的B的class文件和编译的时候用的不是一个了。于是这个异常就被抛了出来。

ClassA ->AbstractClassB  ClassA 依赖于AbstractClassB，通常A是我们自己开发的类，而B则是引用的第三方jar包里面的抽象类。我们的项目中又存在AbstractClassB的多个实现版本，比如：1.0，1.2，2.0等版本，通常主版本号发生了改变的话，一般都是不兼容的。

