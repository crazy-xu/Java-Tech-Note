## 类加载机制
指我们将类的字节码文件所包含的数据读入内存，同时我们会提供数据的访问入口的一种特殊机制，类加载的最终产品是数据访问入口。

#### 加载.class文件的方式：
* 从本地文件系统中直接加载 
* 通过网络下载.class文件
> 场景：Web Applet 也就是我们的小程序应用
* 从zip、jar等归档文件中加载.class文件
> 后续演变成jar、war格式
* 从专有数据库中提取.class文件
> jsp应用从专有数据库中提取.class文件，较为少见
* 将Java源文件动态编译为.class文件，也就是运行时计算而成
> 动态代理
* 从加密文件中获取
> 防class文件被反编译的保护措施

### 装载（Load）
> 查找和导入class文件
* 1、通过一个类的的全限定名获取定义此类的二进制字节流
* 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 
* 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

方法区：类信息、静态变量、常量<br />
堆：代表被加载类的java.lang.Class对象<br />
即时编译之后的热点代码并不在这个阶段进入方法区。
### 链接（Link）
#### 验证（Verify） 
* 文件格式验证
> 验证是否符合Class文件格式的规范，并能被当前版本的虚拟机处理，保证输入的字节流能正确的解析并存储于方法区内。
* 元数据验证
> 对类的元数据信息进行语义校验（Java语法），保证不存在不符合Java语法规范的元数据信息。
* 字节码验证
> 进行数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
* 符号引用验证
> 这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。
* -Xverify:none 取消验证

#### 准备（Prepare）
* 为类变量（静态变量）分配内存并且设置该类变量的默认初始值。
* final在编译的时候就会分配了，准备阶段会显式初始化。（ConstantValue（final,static,基本类型和String）通知虚拟机自动为静态变量赋值）
* 不会为实例变量（也就是没加static）分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

> 进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象
一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a=1;那么a在准备阶段过后
的初始值为0，不为1，这时候只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编
译后，存放于类构造器()方法之中，所以a被赋值为1是在初始化阶段才会执行。

#### 解析（Resolve）
> 把类中的符号引用转换为直接引用
>> 符号引用就是一组符号来描述目标，可以是任何字面量。引用的目标并不一定已经加载到了内存中。
   直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
> 
> 对解析结果进行缓存。除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。


### 初始化（Initialize）
> 在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，比如赋值。

> 对类变量进行初始值设定有两种方式：
> * 声明类变量是指定初始值
> * 使用静态代码块为类变量指定初始值

> JVM初始化步骤：
> * 假如这个类还没有被加载和连接，则程序先加载并连接该类
> * 假如该类的直接父类还没有被初始化，则先初始化其直接父类
> * 假如类中有初始化语句，则系统依次执行这些初始化语句

### 使用（Use）
* 主动引用
> 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用有六种：
> * 创建类的实例，也就是new的方式
> * 访问某个类或接口的静态变量，或者对该静态变量赋值
> * 调用类的静态方法
> * 反射（如 Class.forName(“com.carl.Test”)）
> * 初始化某个类的子类，则其父类也会被初始化
> * Java虚拟机启动时被标明为启动类的类（JvmCaseApplication），直接使用java.exe 命令来运行某个主类
* 被动引用
> * 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
> * 定义类数组，不会引起类的初始化。
> * 引用类的static final常量，不会引起类的初始化（如果只有static修饰，还是会引起该类初始化的）。

### 卸载（Unload）
> 在类使用完之后，如果满足下面的情况，类就会被卸载：
> * 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
> * 加载该类的ClassLoader已经被回收。
> * 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

> 如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。但是一般情况下启动类加载器加载的类不会被卸载，而我们的其他两种基础类型的类加载器只有在极少数情况下才会被卸载。

## 类加载器
> 负责读取Java字节代码，并转换成java.lang.Class类的一个实例的代码模块。
> 
> 类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。
> 
> 一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。


* 1）Bootstrap ClassLoader
> 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。
* 2）Extension ClassLoader
> 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。
* 3）App ClassLoader
> 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。
* 4）Custom ClassLoader  
> 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。

三种基础的类加载器做为我们的三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于你本机的类）。

```
public static void main(String[] args) {
    System.out.println(new Party().getClass());
    System.out.println(new Party().getClass().getClassLoader());
    System.out.println(new Party().getClass().getClassLoader().getParent());
    System.out.println(new Party().getClass().getClassLoader().getParent().getParent());
    System.out.println(new String().getClass().getClassLoader());
}
class com.lzfinance.bt.party.entity.Party
sun.misc.Launcher$AppClassLoader@7b7035c6
sun.misc.Launcher$ExtClassLoader@3da997a
null
null
```

### JVM类加载机制的三种方式

* 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

* 父类委托，“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。

* 缓存机制，缓存机制将会保证所有加载过的Class都将在内存中缓存，当程序中需要使用某个Class时，类加载器先从内存的缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进
  制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效.对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。

> “双亲委派”机制只是Java推荐的机制，并不是强制的机制。
> 
> 我们可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。
#### 打破双亲委派
* SPI
> JDK提供接口，供应商提供服务。编程人员编码时面向接口编程，然后JDK能够自动找到合适的实现。
* OSGI
> OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。
* 自定义类加载器